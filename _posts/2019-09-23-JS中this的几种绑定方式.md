---
layout: post
title: "JS中this的绑定方式"
date: 2019-09-23
author: "Yeqiang"
tags:
  - JS
---

一般来说，this 的上下文是在调用时被绑定的。除了箭头函数，箭头函数的 this 是在定义时就绑定了。那既然与函数的调用相关，就需要确定函数的调用位置，为了明确这一点，就需要分析调用栈，也就是为了到达当前执行位置所调用的所有函数。

```js
function baz() {
  // 当前调用栈是：baz
  // 因此当前调用位置是全局作用域
  console.log("baz");
  bar();
}
function bar() {
  // 当前调用栈是baz=>bar
  // 因此当前调用位置在baz中
  console.log("bar");
  foo();
}
function foo() {
  // 当前调用栈是baz=>bar=>foo
  // 因此当前调用位置在bar中
  console.log("foo");
}
baz();
```

### 绑定规则

关于 this 的绑定有 4 条规则，我们需要找到调用位置，并判断适用于哪一条

#### 默认绑定

首先介绍的就是最常见的调用类型：独立函数调用。在这种情况下使用的是默认绑定。代码如下

```js
function foo() {
  console.log(this.a);
}
var a = 2;
foo(); //2
```

在这段代码中，因为 foo()是在全局作用域中调用的，因此内部的 this 也就指向了全局对象。具体来说，如果某个函数被不带任何修饰的函数引用进行调用，那就只能使用默认绑定。  
这里有个细节，在严格模式中，不能将全局对象用于默认绑定

#### 隐式绑定

接下来需要考虑的情况是调用位置是否有上下文对象，或者说是否被某个对象拥有或包含。代码如下

```js
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo
};
obj.foo(); //2
```

严格来说，obj 并没有拥有 foo 这个函数，这里只是一个对 foo 的引用。但是，在调用时，会使用 obj 上下文来引用函数
