---
layout: post
title: "js函数式编程(一)"
date: 2018-11-08
author: "Yeqiang"
tags:
  - 翻译
---

[原文链接](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch1.md/#chapter-1-why-functional-programming)

## 第一章：为什么要用函数式编程？

> 函数式编程程序员(名词解释)：那些把变量命名为“x”，把方法命名为“f”，把代码模式命名为“zygohistomorphic prepromorphism”的人  
> James Iry @jamesiry 5/13/15  
> [twitter 链接](https://twitter.com/jamesiry/status/598547781515485184)

从各种意义上来说，函数式编程(FP)都不是一个新的概念。它几乎存在于整个编程的历史进程中。然而，我不确定这样说起来是否公正，但是....它在全世界的开发者当中都不是一个主流概念直到或许是最近几年。我认为 FP 更像是一个学术领域。  
然而，现在一切都变了。现在越来越多的人对 FP 表示了高涨的兴趣，不光是在语言层面甚至包括库和框架。你很幸运能读到这段文字因为你会最终认识到 FP 是一种你无法再忽视的东西。或者你像我一样曾经尝试学习 FP 很多次但是最终在那些长篇大论或者是数学符号下败下阵来。  
第一章的目的是为了回答一些问题，比如“为什么我要在我的代码里使用 FP”以及“轻型的 JavaScript FP 和其他人说的 FP 相比如何？”。在我们做完这些基础工作后，在剩下的章节里，我们将会一部分一部分的揭示用轻型函数式编程写代码需要用到的技术和代码模式。

---

### 匆匆一瞥

让我们通过一段 使用前-使用后 的代码来简单的举例说明“轻型 JS 函数式编程”的概念。代码如下

```js
var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg(); // The magic number is: 42

// ***************

function calculateMagicNumber() {
  for (let fave of faves) {
    magicNumber = magicNumber + fave;
  }
}

function pickFavoriteNumbers() {
  for (let num of numbers) {
    if (num >= 10 && num <= 20) {
      faves.push(num);
    }
  }
}

function outputMsg() {
  var msg = `The magic number is: ${magicNumber}`;
  console.log(msg);
}
```

现在来考虑一种最终输出相同但是非常不一样的方式：

```js
var sumOnlyFavorites = FP.compose([
  FP.filterReducer(FP.gte(10)),
  FP.filterReducer(FP.lte(20))
])(sum);

var printMagicNumber = FP.pipe([
  FP.reduce(sumOnlyFavorites, 0),
  constructMsg,
  console.log
]);

var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];

printMagicNumber(numbers); // The magic number is: 42

// ***************

function sum(x, y) {
  return x + y;
}
function constructMsg(v) {
  return `The magic number is: ${v}`;
}
```
一旦你理解了FP和Functional-Light，下面这段话就是你在读第二段代码的心里过程：
> 我们首先创建一个由其它三个方法组合而成的方法`sumOnlyFavorites(..)`。我们将两个过滤条件组合起来，一个是判断值是否大于等于10，另一个判断小于等于20.然后我们将`sum(..)`这个reducer放到transducer composition中。`sumOnlyFavorties(..)`这个方法的结果是一个判断一个值是否通过了所有过滤条件的reducer，并且如果通过，将值添加到一个累加值中。  
> 然后我们创建另一个叫做`printMagicNumber(..)`的方法，这个方法首先reduce一串由我们刚刚定义的`sumOnlyFavorities(..)`方法产生的数字，然后返回所有通过*最爱*判断的数字的和。然后`printMagicNumber(..)`方法将这个最终值通过管道传递给`constructorMsg(..)`，这个值将被拼接成字符串最终由`console.log(..)`打印出来

所有这些代码片段对于FP开发者来说很熟悉但是目前来说你可能非常不熟悉。这本书将会带你推理整个过程，最终让FP对你来说和其他代码一样可读。  
对于这两段代码比较还有其他几个备注：  
+ 对大多数读者来说，第一段代码相比第二段更优雅/可读/可维护。这是完全正确的。你说对了。我敢打包票只要你坚持读完整本书，并且写下所有练习代码，第二段代码会变得自然的多，或许你会更倾向与它。
+ 你可能已经写过很多代码或者是使用和上面两段代码完全不同的方式。这也没问题。这本书的内容并不是命令你必须用某种方式来写代码。这本书的目的是举例说明不同的代码风格的好处/坏处然后让你自己去决定。在书的结尾，你的代码风格可能会比现在更贴近第二段。
+ 也有可能你已经是一个资深的FP开发者，瞄了几眼开头，想看看有什么有用的知识点。第二段代码对你来说肯定有些地方很熟悉。但是我敢打赌你肯定冒出过“嗯....，我还没有用这种方式实现过”这样的想法。这很合情合理。

不管你们出于什么目的，欢迎你们！

---

### 信心
在我作为软件开发(js)的老师的职业生涯中，我所做的一切都遵循一个简单的前提：你不信任的代码就是你没理解的代码。反过来也一样：你没理解的代码你也无法信任它。引申开来说，如果你无法信任或者理解你的代码，那你也无法确认你的代码是否能解决问题。你只是把项目跑起来，然后祈祷一切正常。  
我说的信任是什么意思呢？我的意思是你可以通过直接读代码而不是运行代码就能知道这段代码做了什么；你不能觉得它应该怎么样。通常来说，我们倾向于通过运行测试用例来保证代码的正确性。我不是说测试这个流程不好，而是我觉得我们应该努力做到完全理解我们的代码，这样即使在运行测试用例之前就能知道能通过测试。  
关于FP的基础技术，都遵循着一个设计理念
