---
layout: post
title: "js函数式编程(一)"
date: 2018-11-08
author: "Yeqiang"
tags:
  - 翻译
---

[原文链接](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch1.md/#chapter-1-why-functional-programming)

## 第一章：为什么要用函数式编程？

> 函数式编程程序员(名词解释)：那些把变量命名为“x”，把方法命名为“f”，把代码模式命名为“zygohistomorphic prepromorphism”的人  
> James Iry @jamesiry 5/13/15  
> [twitter 链接](https://twitter.com/jamesiry/status/598547781515485184)

从各种意义上来说，函数式编程(FP)都不是一个新的概念。它几乎存在于整个编程的历史进程中。然而，我不确定这样说起来是否公正，但是....它在全世界的开发者当中都不是一个主流概念直到或许是最近几年。我认为 FP 更像是一个学术领域。  
然而，现在一切都变了。现在越来越多的人对 FP 表示了高涨的兴趣，不光是在语言层面甚至包括库和框架。你很幸运能读到这段文字因为你会最终认识到 FP 是一种你无法再忽视的东西。或者你像我一样曾经尝试学习 FP 很多次但是最终在那些长篇大论或者是数学符号下败下阵来。  
第一章的目的是为了回答一些问题，比如“为什么我要在我的代码里使用 FP”以及“轻型的 JavaScript FP 和其他人说的 FP 相比如何？”。在我们做完这些基础工作后，在剩下的章节里，我们将会一部分一部分的揭示用轻型函数式编程写代码需要用到的技术和代码模式。

---

### 匆匆一瞥

让我们通过一段 使用前-使用后 的代码来简单的举例说明“轻型 JS 函数式编程”的概念。代码如下

```js
var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg(); // The magic number is: 42

// ***************

function calculateMagicNumber() {
  for (let fave of faves) {
    magicNumber = magicNumber + fave;
  }
}

function pickFavoriteNumbers() {
  for (let num of numbers) {
    if (num >= 10 && num <= 20) {
      faves.push(num);
    }
  }
}

function outputMsg() {
  var msg = `The magic number is: ${magicNumber}`;
  console.log(msg);
}
```

现在来考虑一种最终输出相同但是非常不一样的方式：

```js
var sumOnlyFavorites = FP.compose([
  FP.filterReducer(FP.gte(10)),
  FP.filterReducer(FP.lte(20))
])(sum);

var printMagicNumber = FP.pipe([
  FP.reduce(sumOnlyFavorites, 0),
  constructMsg,
  console.log
]);

var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];

printMagicNumber(numbers); // The magic number is: 42

// ***************

function sum(x, y) {
  return x + y;
}
function constructMsg(v) {
  return `The magic number is: ${v}`;
}
```

一旦你理解了 FP 和 Functional-Light，下面这段话就是你在读第二段代码的心里过程：

> 我们首先创建一个由其它三个方法组合而成的方法`sumOnlyFavorites(..)`。我们将两个过滤条件组合起来，一个是判断值是否大于等于 10，另一个判断小于等于 20.然后我们将`sum(..)`这个 reducer 放到 transducer composition 中。`sumOnlyFavorties(..)`这个方法的结果是一个判断一个值是否通过了所有过滤条件的 reducer，并且如果通过，将值添加到一个累加值中。  
> 然后我们创建另一个叫做`printMagicNumber(..)`的方法，这个方法首先 reduce 一串由我们刚刚定义的`sumOnlyFavorities(..)`方法产生的数字，然后返回所有通过*最爱*判断的数字的和。然后`printMagicNumber(..)`方法将这个最终值通过管道传递给`constructorMsg(..)`，这个值将被拼接成字符串最终由`console.log(..)`打印出来

所有这些代码片段对于 FP 开发者来说很熟悉但是目前来说你可能非常不熟悉。这本书将会带你推理整个过程，最终让 FP 对你来说和其他代码一样可读。  
对于这两段代码比较还有其他几个备注：

- 对大多数读者来说，第一段代码相比第二段更优雅/可读/可维护。这是完全正确的。你说对了。我敢打包票只要你坚持读完整本书，并且写下所有练习代码，第二段代码会变得自然的多，或许你会更倾向与它。
- 你可能已经写过很多代码或者是使用和上面两段代码完全不同的方式。这也没问题。这本书的内容并不是命令你必须用某种方式来写代码。这本书的目的是举例说明不同的代码风格的好处/坏处然后让你自己去决定。在书的结尾，你的代码风格可能会比现在更贴近第二段。
- 也有可能你已经是一个资深的 FP 开发者，瞄了几眼开头，想看看有什么有用的知识点。第二段代码对你来说肯定有些地方很熟悉。但是我敢打赌你肯定冒出过“嗯....，我还没有用这种方式实现过”这样的想法。这很合情合理。

不管你们出于什么目的，欢迎你们！

---

### 信心

在我作为软件开发(js)的老师的职业生涯中，我所做的一切都遵循一个简单的前提：你不信任的代码就是你没理解的代码。反过来也一样：你没理解的代码你也无法信任它。引申开来说，如果你无法信任或者理解你的代码，那你也无法确认你的代码是否能解决问题。你只是把项目跑起来，然后祈祷一切正常。  
我说的信任是什么意思呢？我的意思是你可以通过直接读代码而不是运行代码就能知道这段代码做了什么；你不能觉得它应该怎么样。通常来说，我们倾向于通过运行测试用例来保证代码的正确性。我不是说测试这个流程不好，而是我觉得我们应该努力做到完全理解我们的代码，这样即使在运行测试用例之前就能知道能通过测试。  
关于 FP 的基础技术，都遵循着一个设计理念,那就是只要看到代码就对我们的程序非常有自信的心态。那些理解了 FP 和那些在项目中熟练使用的人，可以写出他们及其他人可读并判断出运行效果的代码。  
 当我们使用那些能避免或减少各种 bug 的技术时我们也将更有自信。这可能就是 FP 最大的卖点：FP 的项目通常 bug 更少，并且一般出现在更显眼的地方，这样就更容易发现并修改它们。FP 的代码通常都是 bug-弱化的，当然还做不到完全没 bug 的情况。  
在你阅读这本书的过程中，你将会对你的代码更有自信，因为你将使用那些已经被验证过的代码风格和实践；并且你会避免出一些最常见的 bug！

---

### 交流

为什么 FP 重要？为了回答这个问题，我们需要回过头去然后讲讲为什么编程本身是重要的。  
你可能会觉得惊讶。但是我并不认为代码主要就是给电脑输入一串命令。实际上，我认为那些指示电脑如何工作的代码也算是个开心的意外。  
我深刻的意识到代码更多的角色是充当与其他人交流的中介。  
你可能会有这样的经历，你写代码的时间实际上大部分都花在了读那些已经存在的代码。只有很少一部分人才有特权可以直接甩手去写新的代码并且从不用处理其他人(或者前任)的代码。  
粗略估计，开发者维护代码的 70%的时间里都是在看代码并试着去理解它。这真是让人大开眼界，70%。难怪全球的开发者平均每天写 10 行代码。我们每天要花 7 个小时来看代码为了知道这 10 行代码的运行结果！  
我们需要更关注我们代码的可读性，顺便一提，可读性不应该仅仅是更少的代码。  
如果我们需要花时间致力于让我们的代码更具可读性和可理解性，那 FP 在这个过程中起了非常重要的作用。FP 的原则是很明确的：深度研究的，审核通过的，可被证实的。花时间来学习和使用这些 FP
的原则会让你的代码对于你和其他人来说更熟悉、更容易接受。提高代码的熟悉程度，并且意思到这样带来的好处，会最终提高代码的可读性。  
举个例子，一旦你知道了`map(..)`的用法，你就能在任何项目中一眼就看到并明白它的作用。但是你每次看到`for`循环，你就需要看完循环里的所有代码才能理解它的作用。你或许熟悉`for`循环的语法，但你不一定知道它的作用；这就需要每次都看一遍代码。  
只要那些一眼就能看出作用的代码越来越多，我们就不再需要花时间来研究这段代码的作用，我们的生产力就能被解放出来去关注更高层面的逻辑；这才是最需要我们关注的事。  
FP(至少在没有那些专业术语的压力下)是一种编写可读代码的最有效的工具。这就是为什么它是这么的重要。

---

### 可读性

可读性不是一个二元特征。它主要是一个描述我们和代码之间的关系的主观事实。并且它会随着你的技术和理解力的提升而不断的变化。我的经历和下面的图表很类似，并且据说我接触过很多人也有类似的情况。  
![学习曲线图](/img/in-post/FP/fig17.png)
在阅读这本书的过程中，你可能会发现你也会经历和图中一样的过程。但是鼓起勇气，只要你坚持下去，这条曲线终将向上。  
*命令式*通常用来描述大多数人写的代码。这些代码致力于指示电脑如何完成一些工作。称述性的代码---我们将要学习的，依附于 FP 原则的风格的代码--更趋向于描述将要输出什么。  
让我们回顾下之前提到的两段代码。  
第一段是命令式的，重点在于如何执行任务；到处充斥着`if`语句，`for`循环，临时变量，再分配，变量突变，有副作用的方法和方法之间潜在的数据流动。你当然可以通过走完它的逻辑来知道数据是如何流动和改变的，但这一点也不清晰或者简单。  
第二段代码更具叙述性，它没有用前面提到的命令式的技术。可以看到它没有明显的条件语句，循环，副作用，重命名或者突变；相反的，它使用了常见的(对于 FP 世界来说)和可信任的代码风格像是条件过滤，reduce，转换和组合。关注点从低阶的 _如何_ 做提升到了高阶的输出 _什么_ 。  
不同于用一堆搞乱代码的`if`语句来判断一个数字，我们把它交给一个常见的 FP 函数`gte(..)`(大于等于)，然后我们把时间花在更重要的任务比如将这个过滤条件与另外一个过滤条件及一个累加方法结合起来。  
另外，第二段代码中数据的流动也非常明确：

- 1 一串数字进入`printMagicNumber(..)`函数
- 2 通过`sumOnlyFavorities(..)`方法一次一个的处理这些数字，最终得出只有我们最喜欢的数字的和。
- 3 这个和会通过`constructMsg(..)`方法转变成一段信息
- 4 这段信息会通过 console.log 方法打印出来

你可能还是觉得这种方法有点复杂，而那段命令式的代码更容易理解。你对那样的代码更熟悉；熟悉度对我们判断可读性有很大的影响。不过在这本书的结尾，你就会从第二段代码的叙述性的风格中获益，并且这份熟悉会突然展现它的可读性。  
我知道在这个时候让你相信这个就像天降神迹一样。  
这样会花费更多时间，有时候更多代码，为了提高代码的可读性以及减少或者消除许多导致 bug 的错误，如果按照我的建议的话。实话说，当我开始写这本书的时候，我还从没有写过(甚至说完全理解)第二段代码。不过我现在了解的更多了，它对我而言也更自然和顺眼了。  
如果你期望通过 FP 重构，会像魔法银弹一样，会迅速的将你的代码变得更优雅，更简洁，更灵活，更易维护----从短期来说，这很简单----不幸的是，这根本不现实。  
FP 是一种非常不同的方式关于代码应该如何组织，让数据的流动更明确以及帮助你的读者跟随你的思路。这将花费时间。这份努力是十分值得的，但这可能会是条险路。  
它仍然需要我多次尝试将一系列命令式代码重构为更具说明性的 FP，然后才能得到足够清楚的东西让我以后再理解。我发现转换到 FP 是一个缓慢的迭代过程，而不是从一个范例到另一个范例的快速二进制翻转。  
我还将“之后教它”测试应用到每一段我写的代码中。每次我写了一段代码，我都会丢在那几个小时或者几天，然后回来并用一种新的眼光来看它，并且假装我要把它教给或者解释给其他人听。通常来说，前几次都很混乱，所以我会调整然后重复。  
我并不是想打击你。我真的希望你能披荆斩棘。我很高兴我我做的了。我终于可以看到那条曲线向着提高可读性的方向向上弯曲了。这一切都是值得的。对你来说也一样。

---

### 观点
大多数其它的FP代码似乎都是采用的自上而下的方法，不过我们现在要反其道而行之：从底层向上，我们将会展现出那些老道的FP程序员都会承认的构成了他们工作脚手架的最基础的原则。但是大多数情况下我们会远离那些让初学者烦恼的专业术语和数学符号。  
我认为你如何描述一个东西并不重要，重要的是你要理解它是什么以及它的工作原理。这并不是说共享术语不重要--这在经验丰富的程序员之间确实减少了沟通成本。但是对于初学者来说，这可能让他们分心。  
所以这本书会更多的注重那些基础概念而不是奇技淫巧。这不是说书中就不会有专业术语；这是肯定会有的。但是不要过分陷入那些陈词滥调。必要的时候，要透过现象看本质。  
在这里我把没有那么正式的实践叫做“轻度的函数式编程”是因为我觉得真正的函数式编程之所以让人诟病就在于如果你没有准备好正式的使用它，那它的概念可能会把你淹没。我这可不是瞎猜的；这是我个人真实的故事。甚至在教过FP和写了这本书之后，我还是要说FP中的形式主义和符号对我是一个非常难的难点。我试了很多次，但似乎还是无法完全掌握它。  
我知道很多FP开发者觉得形式主义本身可以帮助学习。但我觉得在你到底一个舒适区之前，都存在着一个难以越过的悬崖。如果你正好有数学背景或者甚至有CS的经验，那这些对于你来说更容易接受。但对于一些人并不是这样，并且不管怎么努力，形式主义总是在阻碍着我们。  

--- 
### 如何找到平衡点
如果你的编程生涯足够长，你可能不止一次的听到这个词“YAGNI”：“你不需要它”。这个原则主要来自于极端情况下的编程以及实现一个暂时不用的功能的高风险和高成本。  
有些时候我们觉得这个功能以后可能用到，现在就和其它工作一起做了更简单点，然后我们发现我们想错了，这个功能并不需要，或者需求变更了。有些时候我们猜对了，但是功能做的太早了，反而占用了完成真正需要的功能的时间；在分散精力的时候产生了机会成本。  
YAGNI问题让我们记住了一点：尽管有时候这听上去有点反常，但是我们应该只有需要的时候才做某些工作。我们总是倾向于夸大预计的之后再添加这个功能的重构成本。奇怪的是，之后再做并没有我们想的那么难。  
在使用函数式编程的时候，我有句忠告：这本书里会有很多有趣的、引人入胜的代码风格，但是虽然你发现了一些让人激动的代码模式应用，它不一定适合用到你的代码中。  
这就是我和其它学院派的FP开发者的不同之处：你*可以*用FP不意味着你*应该*用。而且，分解一个问题可以有很多方法，即使你已经学会了一种复杂的更能保证稳定性和可扩展性的方法，一个更简单的FP模式在同样的问题上可能更有效率。  
一般来说，我建议在你代码中寻求一个平衡点，并且在你完全掌握FP之前在你的项目中保守使用FP的理念。在做决定时记得YAGNI原则，如果某种模式或概念可以帮助部分代码更具可读性才选择它，而不只是介绍了一个没有背书的奇技淫巧。  
> 提醒一点，所有没有用到的可扩展点不仅仅表示努力白费了，它还有可能妨碍你。  
> Jeremy D. Miller @jeremydmiller 2/20/15  
> [twitter](https://twitter.com/jeremydmiller/status/568797862441586688)

记住，你写的每一行代码都都有相关的阅读成本。读者可能是团队里的其他人，甚至是未来的你。没有一个人会对你的充满了自作聪明，不必要的奇技淫巧，只是为了显示你的FP技巧的代码留下好印象。  
最好的代码就是未来也最具可读性的代码，因为它在能够/应该怎么做(理想主义)和必须怎么做(现实主义)之间正好找到了平衡点。  

---

### 参考资料
我为了写这些文字翻阅了很多资料。我相信你们也可以从中获益许多，所以我想把他们列出来。  
#### 书籍
一些你必须读的FP/JS的书
+ [Professor Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/ch1.html) by [Brian Lonsdorf](https://twitter.com/drboolean)
+ [JavaScript Allongé](https://leanpub.com/javascriptallongesix) by [Reg Braithwaite](https://twitter.com/raganwald)
+ [Functional JavaScript](http://shop.oreilly.com/product/0636920028857.do) by [Michael Fogus](https://twitter.com/fogus)
  
#### 博客/网站
其它一些你应该看看的内容
+ [Fun Fun Function Videos](https://www.youtube.com/watch?v=BMUiFMZr7vk) by [Mattias P Johansson](https://twitter.com/mpjme)
+ [Awesome FP JS](https://github.com/stoeffel/awesome-fp-js)
+ [Kris Jenkins](http://blog.jenkster.com/2015/12/what-is-functional-programming.html)
+ [Eric Elliott](https://medium.com/@_ericelliott)
+ [James A Forbes](https://james-forbes.com/)
+ [James Longster](https://github.com/jlongster)
+ [André Staltz](http://staltz.com/)
+ [Functional Programming Jargon](https://github.com/hemanth/functional-programming-jargon#functional-programming-jargon)
+ [Functional Programming Exercises](https://github.com/InceptionCode/Functional-Programming-Exercises)

#### 第三方库
这本书里的代码片段大部分不是从第三方库里拿来的。每次我们要开始实践时，我们都会在单独的，简单的JS代码里引导实现。不过，当你开始在真正的项目里使用FP时，你会需要第三方库来提供一些常用的高性能，稳定的方法。  
顺便一说，你要看下你用的第三方库的文档来保证你明白它是如何工作的。这些库和我们书里写的代码会有很多共同点，但肯定也有一些不同之处，甚至是在常用的库之间。  
这是几个受欢迎的JS版的FP库，它们可以作为你的探索之路的良好的起点。  
+ [Ramda](http://ramdajs.com/)
+ [lodash/fp](https://github.com/lodash/lodash/wiki/FP-Guide)
+ [functional.js](http://functionaljs.com/)
+ [Immutable.js](https://github.com/facebook/immutable-js)

[Appendix C takes a deeper look at these libraries](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/apC.md/#stuff-to-investigate)  

---
### 摘要
