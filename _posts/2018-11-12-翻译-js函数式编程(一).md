---
layout: post
title: "js函数式编程(一)"
date: 2018-11-08
author: "Yeqiang"
tags:
  - 翻译
---

[原文链接](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch1.md/#chapter-1-why-functional-programming)

## 第一章：为什么要用函数式编程？

> 函数式编程程序员(名词解释)：那些把变量命名为“x”，把方法命名为“f”，把代码模式命名为“zygohistomorphic prepromorphism”的人  
> James Iry @jamesiry 5/13/15  
> [twitter 链接](https://twitter.com/jamesiry/status/598547781515485184)

从各种意义上来说，函数式编程(FP)都不是一个新的概念。它几乎存在于整个编程的历史进程中。然而，我不确定这样说起来是否公正，但是....它在全世界的开发者当中都不是一个主流概念直到或许是最近几年。我认为 FP 更像是一个学术领域。  
然而，现在一切都变了。现在越来越多的人对 FP 表示了高涨的兴趣，不光是在语言层面甚至包括库和框架。你很幸运能读到这段文字因为你会最终认识到 FP 是一种你无法再忽视的东西。或者你像我一样曾经尝试学习 FP 很多次但是最终在那些长篇大论或者是数学符号下败下阵来。  
第一章的目的是为了回答一些问题，比如“为什么我要在我的代码里使用 FP”以及“轻型的 JavaScript FP 和其他人说的 FP 相比如何？”。在我们做完这些基础工作后，在剩下的章节里，我们将会一部分一部分的揭示用轻型函数式编程写代码需要用到的技术和代码模式。

### 匆匆一瞥

让我们通过一段 使用前-使用后 的代码来简单的举例说明“轻型 JS 函数式编程”的概念。代码如下

```js
var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg(); // The magic number is: 42

// ***************

function calculateMagicNumber() {
  for (let fave of faves) {
    magicNumber = magicNumber + fave;
  }
}

function pickFavoriteNumbers() {
  for (let num of numbers) {
    if (num >= 10 && num <= 20) {
      faves.push(num);
    }
  }
}

function outputMsg() {
  var msg = `The magic number is: ${magicNumber}`;
  console.log(msg);
}
```

现在来考虑一种最终输出相同但是非常不一样的方式：

```js
var sumOnlyFavorites = FP.compose([
  FP.filterReducer(FP.gte(10)),
  FP.filterReducer(FP.lte(20))
])(sum);

var printMagicNumber = FP.pipe([
  FP.reduce(sumOnlyFavorites, 0),
  constructMsg,
  console.log
]);

var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];

printMagicNumber(numbers); // The magic number is: 42

// ***************

function sum(x, y) {
  return x + y;
}
function constructMsg(v) {
  return `The magic number is: ${v}`;
}
```
一旦你理解了FP和Functional-Light，下面这段话就是你在读第二段代码的心里过程：
> 我们首先创建一个由其它三个方法组合而成的方法`sumOnlyFavorites(..)`。我们将两个过滤条件组合起来，一个是判断值是否大于等于10，另一个判断小于等于20.然后我们将`sum(..)`这个reducer放到transducer composition中。`sumOnlyFavorties(..)`这个方法的结果是一个判断一个值是否通过了所有过滤条件的reducer，并且如果通过，将值添加到一个累加值中。  
> 