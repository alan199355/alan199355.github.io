---
layout: post
title: "js函数式编程(二)：管理函数的输入"
date: 2018-12-25
author: "Yeqiang"
tags:
  - 翻译
---

[原文链接](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch3.md/#chapter-3-managing-function-inputs)

## 第三章 管理函数的输入

[第二章](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch2.md)我们探究了 JS`function`的核心本质，并且为是什么让`function`成为一个 FP&nbsp;*function*的问题打下了基础。但是为了充分利用 FP，我们还需要设计模式和实践来操作函数来改变和调整它们的交换作用--让它们符合我们的意愿。  
具体来说，我们在这一章的注意力都会在函数的参数输入上。就像你把不同类型的函数一起放到你的项目里，你马上就要面对关于参数数量/顺序/类型的矛盾，以及需要在不同的时间指定一些输入。  
事实上，出于可读性风格的考虑，有些时候你会想要用完全隐藏输入的方式来定义函数。  
这些技术毫无疑问对于把函数变成函数式是必需的。

### 一切为了一个参数

想象一下你正在把一个函数传递给一个工具类，这个工具类会传入多个参数给这个函数。但是你可以想要这个函数只接收一个参数。  
我们可以设计一个简单的辅助函数来包括一个函数来确保只有一个参数能传入。因为这是一个有效的让一个函数成为一元的强制执行操作，让我们像这样命名：

```js
function unary(fn) {
  return function onlyOneArg(arg) {
    return fn(arg);
  };
}
```

许多 FP 开发者在这样的代码里倾向于使用更短的`=>`箭头函数语法(具体见[第二章，“没有`function`的函数”](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch2.md/#functions-without-function))，就像这样：

```js
var unary = fn => arg => fn(arg);
```

**注意**：毫无疑问这样更简单，甚至说更稀疏。但是我个人认为不论它在数学符号的对称性上获得了多少，它在函数的整体的可读性上失去的更多，因为它让函数全都变成匿名的了，并且模糊了作用域的界限，让辨认闭包变得有一些模糊。  
一个经常被引用的用到了`unary(..)`的例子是`map(..)`工具类(看[第九章，“Map”](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch9.md/#map))和`parseInt(..)`。`map(..)`对数组中每一个项目调用 mapper 函数，并且每次调用的时候，会传递 3 个参数：`value` `idx` `arr`。  
这通常不是个大问题，除非你用了如果传入了太多参数会出错的对象。思考如下情况：

```js
["1", "2", "3"].map(parseInt);
// [1,NaN,NaN]
```

对于`parseInt(str,radix)`，很明显当`map(..)`把`index`作为第二个参数传入时，被`parseInt(..)`解释为`radix`，而这是我们不想要的。  
`unary(..)`创建了一个  忽略所有只保留传入的第一个参数的函数，这意味着传入的`index`永远不会被`parseInt(..)`接收，也不会被错当作`radix`：

```js
["1", "2", "3"].map(unary(parseInt));
// [1,2,3]
```

### one on one

说到只有一个参数的函数，另一个在 FP 工具库里常用的基础工具函数是一个接收一个参数，然后什么也不做，只是返回未修改的值的函数：

```js
function identity(v) {
  return v;
}

// or the ES6 => arrow form
var identity = v => v;
```

这个工具类看上去太简单了，以至于几乎没什么用。但是即使是简单的函数在 FP 世界里也是有用的。就像他们在表演方面说的一样：没有小角色，只要小演员。  
举个例子，想象你要把一个字符串分割，用一个常规的表达式，但是生成的数组可能有一些空值。为了去掉它们，我们可以使用 JS 的`filter(..)`数组操作(看[第九章，“Filter”](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch9.md/#filter))搭配`identity(..)`作为断言判断：

```js
var words = "   Now is the time for all...  ".split(/\s|\b/);
words;
// ["","Now","is","the","time","for","all","...",""]

words.filter(identity);
// ["Now","is","the","time","for","all","..."]
```

因为`identity(..)`只是简单的返回了传给它的值，JS 强制每个值要么作为`true`要么作为`false`，然后用它来决定是保留还是排除在最终的数组中。  
**小贴士**：另外一个可以在  前面的例子里作为断言判断的一元函数是 JS 内置的`Boolean(..)`函数，它明确的强制把值转换为`true`或`false`。  
另一个使用了`identity(..)`的例子是作为一个默认函数来代替转换。

```js
function output(msg, formatFn = identity) {
  msg = formatFn(msg);
  console.log(msg);
}

function upper(txt) {
  return txt.toUpperCase();
}

output("Hello World", upper); // HELLO WORLD
output("Hello World"); // Hello World
```

你也有可能看到`identity(..)`在`map(..)`函数中作为一个默认转换函数来使用或者作为函数列表中的`reduce(..)`的初始值；这些工具类都会在[第九章](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch9.md)讲到。

### 不被改变的那一个

某些 API 不让你直接往一个方法里传值，而是让你传入一个函数，即使那个函数只是把值返回了。有一个类似的 API 就是 JS Promise 里的`then(..)`方法。

```js
// doesn't work:
p1.then(foo)
  .then(p2)
  .then(bar);

// instead:
p1.then(foo)
  .then(function() {
    return p2;
  })
  .then(bar);
```

很多人称 ES6 的箭头函数是最好的解决方案。

```js
p1.then(foo)
  .then(() => p2)
  .then(bar);
```

但是这里有个 FP 工具类更适合这个任务。

```js
function constant(v) {
  return function value() {
    return v;
  };
}

// or the ES6 => form
var constant = v => () => v;
```

用了这个简洁的 FP 小工具类，我们可以完美解决`then(..)`烦恼。

```js
p1.then(foo)
  .then(constant(p2))
  .then(bar);
```

**警告**：虽然这个`() => p2`箭头函数的版本比`constant(p2)`更短，我还是会鼓励你抵抗住使用它的诱惑。箭头函数返回的值是来自于自身外部的，这在 FP 的角度有一点糟糕。我们会在本书的后期(看[第五章](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch5.md))详细讲解类似操作的隐患。

### 把实参调整到形参

有很多种设计模式或者技巧可以用来让函数签名匹配我们传入的各种各样的实参。  
回忆下[第二章的这个函数签名](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch2.md/#user-content-funcparamdestr)，它强调使用了数组形参解构：

```js
function foo( [x,y,...args] = [] ) {
```

这样的模式是好用的，如果是在传入一个数组而你想要作为一个单独的参数来看的情况下。`foo(..)`因此从技术上来说是一元的 -- 当它被执行，只有一个实参(一个数组)会被传入。但是在函数内部，你需要单独处理不同的输入(`x` `y`等等)。  
然而，有些时候你没有能力去改变函数的声明来使用数组参数解构。举个例子，想象如下函数：

```js
function foo(x, y) {
  console.log(x + y);
}

function bar(fn) {
  fn([3, 9]);
}

bar(foo); // fails
```

你注意到为什么`bar(foo)`失败了吗？  
数组`[3,9]`作为一个单独的值传入`fn()`，但是`foo(..)`期望单独的`x`和`y`。如果我们可以  把`foo(..)`的声明改成`function foo([x,y]) { ..`，一切都 ok 了。或者我们把`bar(..)`的格式改成想`fn(...[3,9])`调用，值`3`和`9`会独立的传入。  
有时会出现这样的情况，两个函数互相不匹配，而你又不能改变它们的声明/定义。那么，要怎么才能把它们结合到一起呢？  
我们可以定义一个辅助函数来调整一个函数，让它能把接收到的单独的数组展开成独立的实参：

```js
function spreadArgs(fn) {
  return function spreadFn(argsArr) {
    return fn(...argsArr);
  };
}

// or the ES6 => arrow form
var spreadArgs = fn => argsArr => fn(...argsArr);
```

**注意**：我把这个辅助函数叫做`spreadArgs(..)`，但是  在 Ramda 这样的库里通常叫做`apply(..)`。  
现在我们可以用`spreadArgs(..)`把`foo(..)`调整到作为`bar(..)` 正确的输入了：

```js
bar(spreadArgs(foo)); // 12
```

目前来看还不清楚为什么这些情况会产生，但是你会经常看到他们。本质上来说，`spreadArgs(..)`让我们能够定义通过数组来`return`多个值的函数，但是仍然可以把这些值作为单独的输入给其它函数。  
在我们讨论`spreadArgs(..)`工具类的时候，让我们同样定义一个处理相反操作的工具类：

```js
function gatherArgs(fn) {
  return function gatheredFn(...argsArr) {
    return fn(argsArr);
  };
}

// or the ES6 => arrow form
var gatherArgs = fn => (...argsArr) => fn(argsArr);
```

**注意**：在 Ramda，这个工具类叫做`unapply(..)`，表示相反于`apply(..)`。我认为术语"展开"/"收集"更能描述发生了什么。  
我们可以用这个工具类来  收集单独的实参到一个数组中，或许是因为我们想要把一个数组参数解构的函数调整到可以  适配另一个需要传递单独的实参的函数。我们将会[第九章详细讲解`reduce(..)`](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch9.md/#reduce)；简而言之，它重复的调用 reducer 函数，带着两个独立的参数，而我们可以把它们收集到一起：

```js
function combineFirstTwo([v1, v2]) {
  return v1 + v2;
}

[1, 2, 3, 4, 5].reduce(gatherArgs(combineFirstTwo));
// 15
```

### 一些现在，一些将来

如果一个函数接收多个实参，你可能会想先指定其中一些而其它的后面再指定。  
思考下这个函数：

```js
function ajax(url, data, callback) {
  // ..
}
```

让我们假设这样的场景，你想要创建几个 API 调用，URLs 已经知道了，而数据和回调函数只有之后才知道。  
当然，你可以延迟创建`ajax`调用直到所有数据都准备好了，然后同时通过一些全局常量把数据提供给 URL。但是还有一种方式是创建一个已经预设置了`url`实参的函数引用。
我们将要做的是创建一个依旧调用了`ajax(..)`的函数，并且手动设置第一个实参为你需要的 API URL，同时等待之后接收另外两个实参。

```js
function getPerson(data, cb) {
  ajax("http://some.api/person", data, cb);
}

function getOrder(data, cb) {
  ajax("http://some.api/order", data, cb);
}
```

手动指定这些函数调用的封装当然是可行的，但这可能会很单调，特别是如果预设置了许多不同的实参，就像这样：

```js
function getCurrentUser(cb) {
  getPerson({ user: CURRENT_USER_ID }, cb);
}
```

一个 FP 开发者非常熟悉的操作是找一个能完成我们重复做的工作的  代码模式，然后试着把这些操作转化成通用的可重用的工具类。事实上，我很确信对于很多读者来说就像是本能，所以这不是 FP 独有的。但是这毫无疑问对于 FP 是重要的。  
为了能构思出这样一个实参预设置的工具类，让我们从概念上审查到底发生了什么，而不是只是看着这里展示的手动执行操作。  
其中一种表达清楚发生了什么的方式是`getOrder(data,cb)`函数是`ajax(url,data,cb)`函数的偏函数应用。这个专业术语来自于在函数调用时实参应用到形参的行为。还有正如你所见，我们只  使用了前面的实参--具体来说，是`url`形参对应的实参--同时留下其它实参后面再应用。  
为了让这个设计模式更正式一点，偏函数应用严格上来说是函数元数的减少；记住，元数的意思就是期望的形参输入数量。我们将原来的`ajax(..)`函数的元数从 3 个减少到`getOrder(..)`函数的 2 个。  
让我们定义一个`partial(..)`工具类：

```js
function partial(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

// or the ES6 => arrow form
var partial = (fn, ...presetArgs) => (...laterArgs) =>
  fn(...presetArgs, ...laterArgs);
```

**提示**：不要只看到这段代码的表面价值。暂停几分钟来消化这个工具类内发生了什么。确认你真的明白了。
