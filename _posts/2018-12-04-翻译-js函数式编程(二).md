---
layout: post
title: "js函数式编程(二)：Function的本质"
date: 2018-11-08
author: "Yeqiang"
tags:
  - 翻译
---

[原文链接](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch2.md/#chapter-2-the-nature-of-functions)

## 第二章：Functions 的本质

FP 不仅仅是使用`function`关键词编程。如果就这么简单的话--我在这里就能结束这本书了。尽管如此，functions 是 FP 的核心。并且我们如何使用 functions 影响到我们的代码是否函数式。  
但是你有多确定你明白 function 真正的含义吗？  
在这一章中，我们将通过探索所有关于 functions 的基础概念来为我们接下来的内容打好基础。事实上，这是一次即使是没用过 FP 的开发者也应该知道的关于 functions 的概念的复习。但是如果我们想要充分了解 FP 的概念，那我们就必须从内到外的了解 functions。  
振作起来，因为这里有许多超过你认识的关于 function 的知识。

### 什么是 function？

“什么是 function”这个问题表面上似乎有一个很明显的答案：一个 function 是代码的集合，可以被运行一次或多次。  
虽然这个定义很合理，但它遗漏了一些非常重要的本质，就是这些本质构成了 FP 中的 function 的核心。因此，让我们深入挖掘来更完全的立即 function。

### 简短的数学复习

我知道我承诺我们会  尽量远离数学，但是在我们继续下面的内容之前先暂时忍耐一会，我们会快速的观察一些关于 function 的基础事实和代数图表。  
你还记得你之前在学校学习的`f(x)`吗？那`y=f(x)`方程呢？  
我们先定义一个方程式比如：`f(x)=2x²+3`。这意味着什么？它的图表是怎样的？下面是图表：
![图表1](/img/in-post/FP/fig2.png)
你可以注意到，对于任意一个`x`的值，比如`2`，如果你把它放到方程式里，你得到`11`，然而`11`是什么？它是`f(x)`的返回值，也就是我们之前说的`y`值。  
换句话说，我们可以把这个输入输出看作是这个图表的曲线上的位于`(2,11)`的一个点。并且对于我们每一个带入的`x`值，我们都能得到一个`y`值作为坐标值。一个是`(0,3)`，另一个是`(-1,5)`。把这些点放在一起，我们就能得到上图所示的抛物曲线图。  
所以这些和 FP 有什么关系呢？
在数学中，一个函数总是接受输入，并且总是给出输出。关于 FP 你会经常听到一个术语，“同态”；这是一个奇特的描述一组值映射到另一组值的方式，就像一个函数的输入与这个函数的输出有关系。  
在代数数学中，那些输入和输出通常被解释为要绘制的坐标的分量。但是，在我们的程序中，我们可以定义具有各种类型的输入输出的函数，即使它们中只有很少的才能被绘制成曲线图。

### 函数 vs 程序

所以为什么都在讨论数学和图表？因为 FP 的本质就是像数学意义上的*函数*一样来使用函数。  
你可能更习惯于以程序里的函数来思考。不同点在哪呢？一个程序是一个随意的功能的集合。它可能有输入，也可能没有。它可能有输出(`return` value)，也可能没有。  
一个函数接受输入并且一定会有`return`返回值。
如果你计划使用 FP，**你应该尽量使用函数**，并且在任何地方都尽量避免程序。所有你的`函数`都一个接收输入，返回输出。  
为什么？关于这个的问题的答案有很多层，我们会在后面的内容一一解释。

### 函数输入

目前为止，我们可以认为函数必须有输入。但是让我们深入挖掘函数的输入是如何工作的。  
你有时候会听到其他人把输入叫做“arguments”或者是“parameters”。所以这些都代表了什么呢？  
Arguments 是你传入的值，而 parameters 是在函数内部接收传入的值的被命名的变量。例子如下：

```js
function foo(x, y) {
  // ..
}

var a = 3;

foo(a, a * 2);
```

`a`和`a * 2`对于`foo(..)`函数就是 arguments，`x`和`y`就是接收 arguments 值的 parameters。  
笔记：在 js 中，并没有规定 arguments 的数量和 parameters 的数量一致。如果你传入的 arguments 数量超过了你用来接收的 parameters 的数量，传入的值也不会改变。这些值可能通过几种不同的方式访问到，包括你可能听过的学院派的`arguments`对象。如果你传入的 arguments 少于声明的 parameters，那些没有对应的 parameter 会被赋值为“undefined”，表示这些值在这个函数的作用域里是可以访问的，只是值为”undefined“。

### 默认参数

在 ES6 中，可以为参数设置默认值。以防对应的实参没有传入，或者传了 undefined，这样会用默认表达式代替。  
如下：

```js
function foo(x = 3) {
  console.log(x);
}
foo(); // 3
foo(undefined); // 3
foo(null); // null
foo(0); // 0
```

总是考虑所有可以提高你的函数的可用性的默认值是一个好的习惯。但是，设置默认值可能会提高阅读代码和理解这个方法是如何调用的  复杂性。 根据自身情况谨慎使用这个功能。

### 计算输入

一个函数期望的 argument 的数量--你想要传入的 arguments 的数量--决定于你声明的 parameters 的数量：

```js
function foo(x, y, z) {
  // ..
}
```

`foo(..)`期望三个 arguments，因为它声明了三个 parameter。这个数字有个专门的术语：参数数量。参数数量是函数在声明时 parameter 的数量。`foo(..)`的参数数量是 3。  
另外，只有一个参数的函数叫做“一元函数”，两个参数的叫“二元函数”，3 个及以上的叫“n 元函数”。  
你可能希望在程序运行时检查函数引用来确定它的参数数量。这可以通过函数的`length`属性活动。

```js
function foo(x, y, z) {
  // ..
}

foo.length; // 3
```

在编译期就确定参数数量的原因是如果一段代码从不同的来源接收函数引用，那就可以根据各自的参数数量传递不同的值。  
举个例子，想象如下情况：一个`fn`函数可能期望一个、两个或者三个 argumentsc，但是你只是想在最后一个位置传递`x`变量：

```js
// `fn` is set to some function reference
// `x` exists with some value

if (fn.length == 1) {
  fn(x);
} else if (fn.length == 2) {
  fn(undefined, x);
} else if (fn.length == 3) {
  fn(undefined, undefined, x);
}
```

提示：函数的`length`熟悉是只读的，并且在你声明时就已经确定。这可以被认为是用来描述函数预期用法的元数据。  
需要注意的是，某些类型的参数列表变化会使函数报告的长度属性与您预期的不同：

```js
function foo(x, y = 2) {
  // ..
}

function bar(x, ...args) {
  // ..
}

function baz({ a, b }) {
  // ..
}

foo.length; // 1
bar.length; // 1
baz.length; // 1
```

在函数调用时计算接收到的 arguments 怎么样呢？这曾经很简单，但是现在情况稍微有点复杂了。每一个函数都有一个`arguments`对象(伪数组)可用，从而保持对每一个传入的 argument 的引用。你可以通过`arguments`的`length`属性来确定实际上有几个参数被传入了。

```js
function foo(x, y, z) {
  console.log(arguments.length);
}

foo(3, 4); // 2
```

在 ES5(以及 strict)模式下，`arguments`是被考虑废弃的属性；许多人尽量  避免使用它。在 JS 中，我们”从不“打破向后兼容，不管这对未来的发展有多大的好处，所以`arguments`永远不会被移除。但是现在一般都建议尽量不使用它。  
不过，我建议`arguments.length`，且仅限于此，还是可以使用的，在那些你需要关注你传入的 arguments 数量的情况下。未来 JS 的某个版本可能会提供一个功能来获取获取传入的 arguments 数量，在不使用`arguments.length`的情况下；如果这真的发生了， 那我们可以完全抛弃`arguments`！  
注意：**永远不要**通过下标访问 arguments，就像`arguments[1]`。只用`arguments.length`，并且是在必须的情况下。  
另外，在你访问 arguments 的时候数组越界了会怎么样？我等会回答你这个问题；但是首先，回过头去认真的问问自己，”为什么我要这么做“。仔细思考下这个问题。  
这种情况可能很少发生；在你写的函数中这应该不常出现。如果你发现你处在这样的情况下，花额外的 20 分钟试着从另外的角度为这个函数设计接口。为这个额外的 argument 命名，即使它是计划外的。  
一个接收不确定数量的 arguments 的函数被  称为可变参数函数。有些人更喜欢这种风格的函数，但是我认为你会发现 FP 开发者想要尽量避免这种情况。  
好了，在这个问题上念叨了够多了。  
假如 n 确实需要通过数组下标的方式来访问 arguments，可能是因为你要访问的 argument 的位置没有正式的形参。我们改怎么做？  
ES6 可以拯救你！我们可以在函数中使用`...`操作符--一般叫做“spread”、“rest”或者(我个人喜好)“gather”：

```js
function foo(x, y, z, ...args) {
  // ..
}
```

看到在 parameter 列表中的`...args`了吗。这个是 ES6 的语法，告诉引擎收集所有(如果有的话)没有分配到已命名 parameter 的 arguments，并且把它们放到一个真正的叫做`args`的数组中。`args`一直都是数组，即使它如果  为空。但是它**不会**包括已经分配给`x` `y` `z`的值，只有其他所有在最前面三个之后传入的值：

```js
function foo(x, y, z, ...args) {
  console.log(x, y, z, args);
}

foo(); // undefined undefined undefined []
foo(1, 2, 3); // 1 2 3 []
foo(1, 2, 3, 4); // 1 2 3 [ 4 ]
foo(1, 2, 3, 4, 5); // 1 2 3 [ 4, 5 ]
```

因此，如果你想设计一个能够接收任意数量 arguments 的函数，在最后使用`...args`(或者随便你喜欢什么名字)。现在，你将有一个真正的，非弃用的，不让人讨厌的数组来访问那些 arguments 值。
需要注意一个问题，那就是`4`其实是在`args[0]`，而不是`args[3]`。并且`args`的`length`不会包括`1` `2` `3`。`...args`其它所有值，不包括`x` `y` `z`。  
你甚至可以在没有声明一个正式参数的情况下使用`...`操作符：

```js
function foo(...args) {
  // ..
}
```

现在`args`就  是全部 arguments 的数组，不管它们在哪，你可以用`args.length`来知道传入了多少 arguments。并且现在你用下标是安全的。不过不要传入 318 个 arguments 以上。

### arguments 数组

如果我想  把一串数组当做 arguments 传入会怎么样呢？

```js
function foo(...args) {
  console.log(args[3]);
}

var arr = [1, 2, 3, 4, 5];

foo(...arr); // 4
```

我们用到了 `...`，但不仅仅在 parameter 列表里；同样用在了调用时的 argument 列表。在这个上下文中它  有相反的作用。在 parameter 列表，它把 arguments 收集到一起。在 argument 列表，它把参数展开。因此`arr`的内容实际上被  展开成独立的 argument 应用到`foo(..)`函数中。你明白了这和直接传递整个`arr`数组引用的不同之处了吗？  
顺便一提，多个参数和`...`可以交叉使用，如下所示

```js
var arr = [2];

foo(1, ...arr, 3, ...[4, 5]); // 4
```

思考下这个对称的场景：在  实参列表，它展开值；在分配值的情况--就像 parameter 列表--因为 arguments 分配给了 parameters，它收集值。  
不管你是  在哪种情况，`...`让我们操作 arguments 数组更容易了。那些用`slice(..)` `contact(..)` `apply(..)`操作 argument 数组的日子都过去了。  
提示：事实上，这些方法不是完全没用。在整本书的代码里会有几个地方需要它们。但是在大多数情况下，`...`都更具可读性，优先级更高。

### parameter 解构

思考下上一章的可变参数函数`foo(..)`

```js
function foo(...args) {
  // ..
}

foo(...[1, 2, 3]);
```
如果我们想要改变这个函数的接口设计，从而让函数调用时传入一个数组而不是单独的argument改怎么做呢？只要去掉这两个`...`就行了：
```js
function foo(args) {
    // ..
}

foo( [1,2,3] );
```
非常简单。但是如果现在我想给传入的数组的前两个设置参数名呢？我们没有单独的命名parameters，因此似乎我们没办法这么做了。  
幸好，ES6的解构赋值可以解决。解构赋值是一种可以把类似结构(对象，数组等等)解构成你想要的格式的方法。代码如下：
```js
function foo( [x,y,...args] = [] ) {
    // ..
}

foo( [1,2,3] );
```
你注意到了parameter列表中的`[..]`中括号了吗？这个叫做形参数组解构。  
在这个例子中，