---
layout: post
title: "vue源码学习-响应式原理(3)-派发更新"
date: 2019-02-27
author: "Yeqiang"
tags:
  - JS
---
上一篇文章我们讲了依赖收集的过程，现在我们来看下修改数据时的依赖派发更新是如何进行的。  
先回顾`defineReactive`的setter部分的代码。
```js
set: function reactiveSetter (newVal) {
  const value = getter ? getter.call(obj) : val
  /* eslint-disable no-self-compare */
  if (newVal === value || (newVal !== newVal && value !== value)) {
    return
  }
  /* eslint-enable no-self-compare */
  if (process.env.NODE_ENV !== 'production' && customSetter) {
    customSetter()
  }
  if (setter) {
    setter.call(obj, newVal)
  } else {
    val = newVal
  }
  childOb = !shallow && observe(newVal)
  dep.notify()
}
```
