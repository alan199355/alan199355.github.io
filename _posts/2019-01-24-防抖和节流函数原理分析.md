---
layout: post
title: "防抖和节流函数原理分析"
date: 2019-01-24
author: "Yeqiang"
tags:
  - JS
---

### debounce
防抖函数：一个函数被频繁触发时，在一定时间内，只让最后一次生效。  
首先分析一下原理，第一次调用时，设置一个定时器，在规定时间之后再执行传入的函数。如果在规定时间之内又被触发，就清除之前的定时器并设置一个新的，直到函数被触发的间隔大于规定时间。以下是一个简单的实现。
```js
function debounce(fn,delay){
    let timer;
    return function(){
        clearTimeout(timer)
        timer = setTimeout(function(){
            fn.apply(this)
        },delay)
    }
}
```
接下来让我们看看lodash库里是怎么实现的
```js
 function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;
  
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
  
        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;
  
          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
  
        function leadingEdge(time) {
          // Reset any `maxWait` timer.
          lastInvokeTime = time;
          // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
          // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }
  
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;
  
          return maxing
            ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
        }
  
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;
  
          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
            (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }
  
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
  
        function trailingEdge(time) {
          timerId = undefined;
  
          // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }
  
        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }
  
        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }
  
        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);
  
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
  
          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              // Handle invocations in a tight loop.
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
```
让我们从入口开始分析
```js
function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
        if (timerId === undefined) {
            return leadingEdge(lastCallTime);
        }
        if (maxing) {
            // Handle invocations in a tight loop.
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
        }
    }
    if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
    }
    return result;
}
debounced.cancel = cancel;
debounced.flush = flush;
return debounced;
```
就和我们的简单版本一样，debounce返回了一个debounced函数，在这里处理主要的逻辑。  
首先，通过`shouldInvoke`判断当前是否应该触发目标函数，该函数定义如下
```js
function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
}
```
这里记录了距离上次调用的时间和距离上次触发的时间。并且判断了4种情况，只要符合其中一条，就返回为true，即应该触发目标函数，分别是：第一次调用；频繁触发已停止，正处于延迟结束阶段；系统时间倒退了，我们同样视为延迟结束阶段；触发了`maxWait`限制。  
当`isInvoking`为true，就进入了触发目标函数的阶段。
```js
if (isInvoking) {
    if (timerId === undefined) {
        return leadingEdge(lastCallTime);
    }
    if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
    }
}
```
先看一下这个`leadingEdge`函数
```js
 // Reset any `maxWait` timer.
lastInvokeTime = time;
// Start the timer for the trailing edge.
timerId = setTimeout(timerExpired, wait);
// Invoke the leading edge.
return leading ? invokeFunc(time) : result;
```